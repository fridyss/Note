# 进程间通信机制

进程间的通信（IPC），有消息（队列/邮箱），管道，信号量（计数信号量，二值信号量），共享内存，Socket。

## 1. 消息

### 1.1  消息队列

​	消息队列提供进程间发送数据块的方法，数据块可以是用户自定义的数据类型，每个数据块大小（MSGMAX）及消息队列总字节数大小（MSGMNB），消息队列数目（MSGMNI ）受系统约束。

​	查看宏定义方式

```shell
cat /proc/sys/kernel/msgmax 最大消息长度 限制
cat /proc/sys/kernel/msgmnb 消息队列总的字节数
cat /proc/sys/kernel/msgmni 消息条目数
```

```c
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
int msgget(key_t key, int msgflg);
int msgrcv(int msqid, void *msg_ptr, size_t msg_gz, long int msgtype, int msgflg);
int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);
```

-   `msgget()` 函数被用来创建新的消息队列或获取已有的消息队列 , 程序必须提供一个键值来命名某个特定的消息队列，进程间通过key来获取`msqid`,进行消息收发，`msgflg` 标记如下IPC_CREAT,IPC_EXCL,IPC_NOWAIT, 必须和权限标志(`rwx`)按位或才能创建一个新的消息队列。成功返回一个非负整数，即该消息队列的标识码(`msqid`)；失败返回-1.

```c
#include <bits/ipc.h>
/* Mode bits for `msgget', `semget', and `shmget'.  */
#define IPC_CREAT	01000		/* Create key if key does not exist. */
#define IPC_EXCL	02000		/* Fail if key exists.  */
#define IPC_NOWAIT	04000		/* Return error on wait.  */
```

-   `msgsnd()` 消息数据添加到消息队列中。`msqid`: 由`msgget()`函数返回的消息队列标识码, `msg_ptr`:指针指向准备发送的消息, `msg_sz`:是`msg_ptr`指向的消息长度,  `msgflg` ：IPC_NOWAIT，队列没有可读消息不等待，返回ENOMSG错误，SG_NOERROR，消息大小超过`msgsz`时被截断。

```c
//msg_ptr 指向数据类型，它必须以一个long int长整数开始，接收者函数将利用这个长整数确定消息的类型
struct msgbuf {
	long  msgtype;
	char mtext[100];
}
```

-   `msgrcv()` 从消息队列接收消息。`msgid` ， `msg_ptr`，`msg_gz`， `msgflg` 参数同`msgsnd()`。 `msgtype`: 0 返回消息队列第一个数据块，>0, 返回等于`msgtype`第一个数据块。返回队列第一条类型小于等于`msgtype`绝对值的消息，并且是满足条件的消息类型最小的消息。
-   `msgctl()` 消息队列的控制函数, `cmd`:是将要采取的动作,（有三个可取值）

```c
#include <sys/msg.h>
/* Control commands for `msgctl', `semctl', and `shmctl'.  */
#define IPC_RMID	0		/* Remove identifier.  */
#define IPC_SET		1		/* Set `ipc_perm' options.  */
#define IPC_STAT	2		/* Get `ipc_perm' options.  */
```

-   应用例程

    `ipc_sender.c`

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/msg.h>
#include <string.h>

struct msg{
    long msgtype;
    char text[128];
};

int main(int argc, char *argv[])
{
    int msgid;
    struct msg test_msg;
    printf("Sender\r\n");
    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);
    if(msgid == -1)
    {
        fprintf(stderr, "msgget error: %d\n", errno);
        return -1;
    }
    
    test_msg.msgtype = 1;
    memset(test_msg.text, 0 , sizeof(test_msg.text) );
    memcpy( test_msg.text, "hello msg!", strlen("hello msg!"));
    if(msgsnd( msgid, (void *)&test_msg, 128, 0) == -1)
    {
        fprintf(stderr, "msgsnd failed\n");
        return -1;
    }
   
    return 0;
}
```

​	`ipc_rev.c`

```c

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/msg.h>

struct msg{
    long msgtype;
    char text[128];
};

int main(int argc, char *argv[])
{
    int msgid;
    struct msg test_msg;
    printf("Recer\r\n");
    msgid = msgget((key_t)1234, 0666 | IPC_CREAT);
    if(msgid == -1)
    {
        fprintf(stderr, "msgget error: %d\n", errno);
        return -1;
    }
    test_msg.msgtype = 1;
    if(msgrcv(msgid, (void *)&test_msg, 128, 0, 0 ) == -1)
    {
        fprintf(stderr, "msgrcv error: %d\n", errno);
        return 0;
    }
    printf("Rev: %s", test_msg.text);
    if(msgctl(msgid, IPC_RMID, 0) == -1)
    {
        return -1;
    }
    return 0;
}
```



### 1.2 消息邮箱



## 2. 信号量



### 2.1  计数信号量



### 2.2 二值信号量



### 2.3 互斥量



## 3. 共享内存



## 4.管道



## 5.Socket



### 5.1 TCP

### 5.2 UDP

## 6.竟争与并发

